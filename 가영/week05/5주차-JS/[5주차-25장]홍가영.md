# 1. 클래스

- 클래스는 생성자 함수와 매우 유사하게 동작하지만 몇 가지 차이가 있음
  - 클래스를 new 연산자 없이 호출하면 에러 발생 ↔ 생성자 함수를 new 연산자 없이 호출하면 일반 함수로서 호출됨
  - 클래스는 상속을 지원하는 extends와 super 키워드를 제공함 ↔ 생성자 함수는 extends와 super 키워드를 지원하지 않음
  - 클래스는 호이스팅이 발생하지 않는 것처럼 동작함 ↔ 함수 선언문으로 정의된 생성자 함수는 함수 호이스팅이 함수 표현식으로 정의한 생성자 함수는 변수 호이스팅이 발생함
  - 클래스 내의 모든 코드에는 암묵적으로 strict mode가 지정되어 실행되며 strict mode를 해제할 수 없음 ↔ 생성자 함수는 암묵적으로 strict mode가 지정되지 않음
  - 클래스의 constructor, 프로토타입 메서드, 정적 메서드는 모두 프로퍼티 어트리뷰트 [[Enumerable]]의 값이 false임 → 다시 말해, 열거되지 않음
- 클래스를 프로토타입 기반 객체 생성 패턴의 단순한 문법적 설탕이라고 보기보다는 새로운 객체 생성 메커니즘으로 보는 것이 합당함

# 2. 클래스 정의

- 클래스는 class 키워드를 사용하여 정의함
- 클래스 이름은 생성자 함수와 마찬가지로 파스칼 케이스를 사용하는 것이 일반적임
- 파스칼 케이스를 사용하지 않아도 에러가 발생하지는 않음

```jsx
// 클래스 선언문
class Person {}
```

- 표현식으로 클래스를 정의할 수도 있음
- 함수와 마찬가지로 이름을 가질 수도 있고, 갖지 않을 수도 있음

```jsx
// 익명 클래식 표현식
const Person = class {};

// 기명 클래스 표현식
const Person = class MyClass {};
```

- 클래스를 표현식으로 정의할 수 있다는 것은 클래스가 값으로 사용할 수 있는 일급 객체라는 것을 의미함
- 즉, 클래스는 일급 객체로서 다음과 같은 특징을 가짐
  - 무명의 리터럴로 생성할 수 있음 → 즉, 런타임에 생성이 가능함
  - 변수나 자료구조(객체, 배열 등)에 저장할 수 있음
  - 함수의 매개변수에게 전달할 수 있음
  - 함수의 반환값으로 사용할 수 있음

# 3. 클래스와 생성자 함수의 정의 방식 비교

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/35537c72-cf48-40f5-b570-748c973a1bbd/75ab4da2-6ae4-483a-9105-9c3a3aac2b01/Untitled.png)

# 4. 클래스 호이스팅

- 클래스는 함수로 평가

```jsx
// 클래스 선언문
class Person {}

console.log(typeof Person); // function
```

- 클래스는 클래스 정의 이전에 참조할 수 없음

```jsx
console.log(Person);

// 클래스 선언문
class Person {}
```

- 클래스 선언문은 마치 호이스팅이 발생하지 않는 것처럼 보이나 그렇지 않음
- 클래스 선언문도 변수 선언, 함수 정의와 마찬가지로 호이스팅이 발생함
- 단, 클래스는 let, const 키워드로 선언한 변수처럼 호이스팅됨
- 따라서 클래스 선언문 이전에 일시적 사각지대(TDZ)에 빠지기 때문에 호이스팅이 발생하지 않는 것처럼 동작함
- var, let, const, function, class 키워드를 사용하여 선언된 모든 식별자는 호이스팅됨
- 모든 선언문은 런타임 이전에 먼저 실행되기 때문임

```jsx
const Person = "";

{
  // 호이스팅이 발생하지 않는다면 ''이 출력되어야 함
  console.log(Person);
  // ReferenceError: Cannot access 'Person' befor initialization

  // 클래스 선언문
  class Person {}
}
```

# 5. 인스턴스 생성

- 클래스는 생성자 함수이며, new 연산자와 함께 호출되어 인스턴스를 생성함

```jsx
class Person {}

// 인스턴스 생성
const me = new Person();
console.log(me); // Person {}
```

- 함수는 new 연산자의 사용 여부에 따라 일반 함수로 호출되거나 인스턴스 생성을 위한 생성자 함수로 호출되지만 클래스는 인스턴스를 생성하는 것이 유일한 존재 이유이므로 반드시 **new 연산자**와 함께 호출해야 함

```jsx
class Person {}

// 클래스를 new 연산자 없이 호출하면 타입 에러가 발생함
const me = Person();
```

- 클래스 표현식으로 정의된 클래스의 경우 다음 예제와 같이 클래스를 가리키는 식별자(Person)를 사용해 인스턴스를 생성하지 않고 기명 클래스 표현식의 클래스 이름(MyClass)을 사용해 인스턴스를 생성하면 에러가 발생함
- 이는 기명 함수 표현식과 마찬가지로 클래스 표현식에서 사용한 클래스 이름은 외부 코드에서 접근 불가능하기 때문임

```jsx
const Person = class MyClass {};

// 함수 표현식과 마찬가지로 클래스를 가리키는 식별자로 인스턴스를 생성해야 한다.
const me = new Person();

// 클래스 이름 MyClass는 함수와 동일하게 클래스 몸체 내부에서만 유효한 식별자다.
console.log(MyClass); // ReferenceError: MyClass is not defined

const you = new MyClass(); // ReferenceError: MyClass is not defined
```

# 6. 메서드

- 클래스 몸체에는 0개 이상의 메서드만 선언할 수 있음
- 클래스 몸체에서 정의할 수 있는 메서드는 constructor(생성자), 프로토타입 메서드, 정적 메서드의 세 가지가 있음

## 6-1. constructor

- 인스턴스를 생성하고 초기화하기 위한 특수한 메서드임
- constructor는 이름을 변경할 수 없음

```jsx
class Person {
  // 생성자
  constructor(name) {
    // 인스턴스 생성 및 초기화
    this.name = name;
  }
}
```

- constructor는 클래스 내에 최대 한 개만 존재할 수 있음
- 만약 클래스가 2개 이상의 constructor를 포함하면 문법 에러가 발생함

```jsx
class Person {
  constructor() {}
  constructor() {}
}
// SyntaxError: A class may only have one constructor
```

- constructor는 생략할 수 있음

```jsx
class Person {}
```

- constructor를 생략하면 클래스에 다음과 같이 빈 constructor가 암묵적으로 정의됨
- constructor를 생략한 클래스는 빈 constructor에 의해 빈 객체를 생성함

```jsx
class Person {
  // constructor를 생략하면 다음과 같이 빈 constructor가 암묵적으로 정의된다.
  constructor() {}
}

// 빈 객체가 생성된다.
const me = new Person();
console.log(me); // Person {}
```

- 프로퍼티가 추가되어 초기화된 인스턴스를 생성하면 constructor 내부에서 this에 인스턴스 프로퍼티를 추가함

```jsx
class Person {
  constructor() {
    // 고정값으로 인스턴스 초기화
    this.name = "Lee";
    this.address = "Seoul";
  }
}

// 인스턴스 프로퍼티가 추가된다.
const me = new Person();
console.log(me); // Person {name: "Lee", address: "Seoul"}
```

- 인스턴스를 생성할 때 클래스 외부에서 인스턴스 프로퍼티의 초기값을 전달하려면 다음과 같이 constructor에 매개변수를 선언하고 인스턴스를 생성할 때 초기값을 전달함
- 이때 초기값은 constructor의 매개변수에게 전달됨

```jsx
class Person {
  constructor(name, address) {
    // 인수로 인스턴스 초기화
    this.name = name;
    this.address = address;
  }
}

// 인수로 초기값을 전달한다. 초기값은 constructor에 전달된다.
const me = new Person("Lee", "Seoul");
console.log(me); // Person {name: "Lee", address: "Seoul"}
```

- 이처럼 constructor 내에서는 인스턴스의 생성과 동시에 인스턴스 프로퍼티 추가를 통해 인스턴스의 초기화를 실행함
- 따라서 인스턴스를 초기화하려면 constructor를 생략해서는 안됨
- constructor는 별도의 반환문을 갖지 않아야 함 → new 연산자와 함께 클래스가 호출되면 생성자 함수와 동일하게 암묵적으로 this, 즉 인스턴스를 반환하기 때문임
- 만약 this가 아닌 다른 객체를 명시적으로 반환하면 this, 즉 인스턴스가 반환되지 못하고 return 문에 명시한 객체가 반환됨

```jsx
class Person {
  constructor(name) {
    this.name = name;

    // 명시적으로 객체를 반환하면 암묵적인 this 반환이 무시된다.
    return {};
  }
}

// constructor에서 명시적으로 반환한 빈 객체가 반환된다.
const me = new Person("Lee");
console.log(me); // {}
```

- 명시적으로 원시값을 반환하면 원시값 반환은 무시되고 암묵적으로 this가 반환됨
- 이처럼 constructor 내부에서 명시적으로 this가 아닌 다른 값을 반환하는 것은 클래스의 기본 동작을 훼손함 → constructor 내부에서 return 문을 반드시 생략해야 함

```jsx
class Person {
  constructor(name) {
    this.name = name;

    // 명시적으로 원시값을 반환하면 원시값 반환은 무시되고 암묵적으로 this가 반환된다.
    return 100;
  }
}

const me = new Person("Lee");
console.log(me); // Person { name: "Lee" }
```

## 6-2. 프로토타입 메서드

- 생성자 함수를 사용하여 인스턴스를 생성하는 경우 프로토타입 메서드를 생성하기 위해서는 다음과 같이 명시적으로 프로토타입에 메서드를 추가해야 함

```jsx
// 생성자 함수
function Person(name) {
  this.name = name;
}

// 프로토타입 메서드
Person.prototype.sayHi = function () {
  console.log(`Hi! My name is ${this.name}`);
};

const me = new Person("Lee");
me.sayHi(); // Hi! My name is Lee
```

- 클래스 몸체에서 정의한 메서드는 생성자 함수에 의한 객체 생성 방식과는 다르게 클래스의 prototype 프로퍼티에 메서드를 추가하지 않아도 기본적으로 프로토타입 메서드가 됨

```jsx
class Person {
  // 생성자
  constructor(name) {
    // 인스턴스 생성 및 초기화
    this.name = name;
  }

  // 프로토타입 메서드
  sayHi() {
    console.log(`Hi! My name is ${this.name}`);
  }
}

const me = new Person("Lee");
me.sayHi(); // Hi! My name is Lee
```

- 생성자 함수와 마찬가지로 클래스가 생성한 인스턴스는 프로토타입 체인의 일원이 됨

```jsx
// me 객체의 프로토타입은 Person.prototype이다.
Object.getPrototypeOf(me) === Person.prototype; // -> true
me instanceof Person; // -> true

// Person.prototype의 프로토타입은 Object.prototype이다.
Object.getPrototypeOf(Person.prototype) === Object.prototype; // -> true
me instanceof Object; // -> true

// me 객체의 constructor는 Person 클래스다.
me.constructor === Person; // -> true
```

- 이처럼 클래스 몸체에서 정의한 메서드는 인스턴스의 프로토타입에 존재하는 프로토타입 메서드가 됨
- 인스턴스는 프로토타입 메서드를 상속받아 사용할 수 있음
- 프로토타입 체인은 기존의 모든 객체 생성 방식(객체 리터럴, 생성자 함수, Object.create 메서드 등)뿐만 아니라 클래스에 의해 생성된 인스턴스에도 동일하게 적용됨 → 생성자 함수의 역할을 클래스가 할 뿐임
- 결국 클래스는 생성자 함수와 같이 인스턴스를 생성하는 생성자 함수라고 볼 수 있음 → 클래스는 생성자 함수와 마찬가지로 프로토타입 기반의 객체 생성 메커니즘임

## 6-3. 정적 메서드

- 인스턴스를 생성하지 않아도 호출할 수 있는 메서드를 말함
- 생성자 함수의 경우 정적 메서드를 생성하기 위해서는 다음과 같이 명시적으로 생성자 함수에 메서드를 추가해야 함

```jsx
// 생성자 함수
function Person(name) {
  this.name = name;
}

// 정적 메서드
Person.sayHi = function () {
  console.log("Hi!");
};

// 정적 메서드 호출
Person.sayHi(); // Hi!
```

- 클래스에서는 메서드에 static 키워드를 붙이면 정적 메서드(클래스 메서드)가 됨

```jsx
class Person {
  // 생성자
  constructor(name) {
    // 인스턴스 생성 및 초기화
    this.name = name;
  }

  // 정적 메서드
  static sayHi() {
    console.log("Hi!");
  }
}
```

- 정적 메서드는 프로토타입 메서드처럼 인스턴스로 호출하지 않고 클래스로 호출함

```jsx
// 정적 메서드는 클래스로 호출한다.
// 정적 메서드는 인스턴스 없이도 호출할 수 있다.
Person.sayHi(); // Hi!
```

- 정적 메서드는 인스턴스로 호출할 수 없음
- 정적 메서드가 바인딩된 클래스는 인스턴스의 프로토타입 체인 상에 존재하지 않기 때문임
- 인스턴스의 프로토타입 체인 상에는 클래스가 존재하지 않기 때문에 인스턴스로 클래스의 메서드를 상속받을 수 없음

```jsx
// 인스턴스 생성
const me = new Person("Lee");
me.sayHi(); // TypeError: me.sayHi is not a function
```

## 6-4. 정적 메서드와 프로토타입 메서드의 차이

1. 정적 메서드와 프로토타입 메서드는 자신이 속해 있는 프로토타입 체인이 다름
2. 정적 메서드는 클래스로 호출하고 프로토타입 메서드는 인스턴스로 호출함
3. 정적 메서드는 인스턴스 프로퍼티를 참조할 수 없지만 프로토타입 메서드는 인스턴스 프로퍼티를 참조할 수 있음

## 6-5. 클래스에서 정의한 메서드의 특징

- function 키워드를 생략한 메서드 축약 표현을 사용함
- 객체 리터럴과는 다르게 클래스에 메서드를 정의할 때는 콤마가 필요 없음
- 암묵적으로 strict mode로 실행됨
- for … in 문이나 Object.keys 메서드 등으로 열거할 수 없음 → 즉, 프로퍼티의 열거 가능 여부를 나타내며, boolean 값을 갖는 프로퍼티 어트리뷰트 [[Enumerable]]의 값이 false임
- 내부 메서드 [[Construct]]를 갖지 않는 non-constructor임 → new 연산자와 함께 호출할 수 없음

# 7. 클래스의 인스턴스 생성 과정

- new 연산자와 함께 클래스를 호출하면 생성자 함수와 마찬가지로 클래스의 내부 메서드 [[Construct]]가 호출됨 → 클래스는 new 연산자 없이 호출할 수 없음

1. **인스턴스 생성과 this 바인딩**

- new 연산자와 함께 클래스를 호출하면 constructor의 내부 코드가 실행되기에 앞서 암묵적으로 빈 객체가 생성됨 → 빈 객체가 바로 클래스가 생성한 인ㅅ턴스임
- 이때 클래스가 생성한 인스턴스의 프로토타입으로 클래스의 prototype 프로퍼티가 가리키는 객체가 설정됨
- 암묵적으로 생성된 빈 객체, 즉 인스턴스는 this에 바인딩됨 → constructor 내부의 this는 클래스가 생성한 인스턴스를 가리킴

1. **인스턴스 초기화**

- constructor의 내부 코드가 실행되어 this에 바인딩되어 있는 인스턴스를 초기화함 → 즉, this에 바인딩되어 있는 인스턴스에 프로퍼티를 추가하고 constructor가 인수로 전달받은 초기값으로 인스턴스의 프로퍼티 값을 초기화함
- 만약 constructor가 생략되었다면 이 과정도 생략함

1. **인스턴스 반환**

- 클래스의 모든 처리가 끝나면 완성된 인스턴스가 바인딩된 this가 암묵적으로 반환됨

```jsx
class Person {
  // 생성자
  constructor(name) {
    // 1. 암묵적으로 인스턴스가 생성되고 this에 바인딩된다.
    console.log(this); // Person {}
    console.log(Object.getPrototypeOf(this) === Person.prototype); // true

    // 2. this에 바인딩되어 있는 인스턴스를 초기화한다.
    this.name = name;

    // 3. 완성된 인스턴스가 바인딩된 this가 암묵적으로 반환된다.
  }
}
```

# 8. 프로퍼티

## 8-1. 인스턴스 프로퍼티

- constructor 내부에서 정의해야 함

```jsx
class Person {
  constructor(name) {
    // 인스턴스 프로퍼티
    this.name = name;
  }
}

const me = new Person("Lee");
console.log(me); // Person {name: "Lee"}
```

## 8-2. 접근자 프로퍼티

- 자체적으로는 값([[Value]] 내부 슬롯)을 갖지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 사용하는 접근자 함수로 구성된 프로퍼티임

```jsx
const person = {
  // 데이터 프로퍼티
  firstName: "Ungmo",
  lastName: "Lee",

  // fullName은 접근자 함수로 구성된 접근자 프로퍼티다.
  // getter 함수
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  },
  // setter 함수
  set fullName(name) {
    // 배열 디스트럭처링 할당: "36.1. 배열 디스트럭처링 할당" 참고
    [this.firstName, this.lastName] = name.split(" ");
  },
};

// 데이터 프로퍼티를 통한 프로퍼티 값의 참조.
console.log(`${person.firstName} ${person.lastName}`); // Ungmo Lee

// 접근자 프로퍼티를 통한 프로퍼티 값의 저장
// 접근자 프로퍼티 fullName에 값을 저장하면 setter 함수가 호출된다.
person.fullName = "Heegun Lee";
console.log(person); // {firstName: "Heegun", lastName: "Lee"}

// 접근자 프로퍼티를 통한 프로퍼티 값의 참조
// 접근자 프로퍼티 fullName에 접근하면 getter 함수가 호출된다.
console.log(person.fullName); // Heegun Lee

// fullName은 접근자 프로퍼티다.
// 접근자 프로퍼티는 get, set, enumerable, configurable 프로퍼티 어트리뷰트를 갖는다.
console.log(Object.getOwnPropertyDescriptor(person, "fullName"));
// {get: ƒ, set: ƒ, enumerable: true, configurable: true}
```

- 접근자 프로퍼티는 클래스에서도 사용할 수 있음

```jsx
class Person {
  constructor(firstName, lastName) {
    this.firstName = firstName;
    this.lastName = lastName;
  }

  // fullName은 접근자 함수로 구성된 접근자 프로퍼티다.
  // getter 함수
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }

  // setter 함수
  set fullName(name) {
    [this.firstName, this.lastName] = name.split(" ");
  }
}

const me = new Person("Ungmo", "Lee");

// 데이터 프로퍼티를 통한 프로퍼티 값의 참조.
console.log(`${me.firstName} ${me.lastName}`); // Ungmo Lee

// 접근자 프로퍼티를 통한 프로퍼티 값의 저장
// 접근자 프로퍼티 fullName에 값을 저장하면 setter 함수가 호출된다.
me.fullName = "Heegun Lee";
console.log(me); // {firstName: "Heegun", lastName: "Lee"}

// 접근자 프로퍼티를 통한 프로퍼티 값의 참조
// 접근자 프로퍼티 fullName에 접근하면 getter 함수가 호출된다.
console.log(me.fullName); // Heegun Lee

// fullName은 접근자 프로퍼티다.
// 접근자 프로퍼티는 get, set, enumerable, configurable 프로퍼티 어트리뷰트를 갖는다.
console.log(Object.getOwnPropertyDescriptor(Person.prototype, "fullName"));
// {get: ƒ, set: ƒ, enumerable: false, configurable: true}
```

## 8-3. 클래스 필드 정의 제안

- 클래스 필드는 클래스 기반 객체지향 언어에서 클래스가 생성할 인스턴스의 프로퍼티를 가리키는 용어임
- 자바의 클래스 필드는 마치 클래스 내부에서 변수처럼 사용됨

```jsx
// 자바의 클래스 정의
public class Person {
  // ① 클래스 필드 정의
  // 클래스 필드는 클래스 몸체에 this 없이 선언해야 한다.
  private String firstName = "";
  private String lastName = "";

  // 생성자
  Person(String firstName, String lastName) {
    // ③ this는 언제나 클래스가 생성할 인스턴스를 가리킨다.
    this.firstName = firstName;
    this.lastName = lastName;
  }

  public String getFullName() {
    // ② 클래스 필드 참조
    // this 없이도 클래스 필드를 참조할 수 있다.
    return firstName + " " + lastName;
  }
}
```

- 자바스크립트의 클래스 몸체에는 메서드만 선언할 수 있음
- 따라서 클래스 몸체에 자바와 유사하게 클래스 필드를 선언하면 문법 에러가 발생함

```jsx
class Person {
  // 클래스 필드 정의
  name = "Lee";
}

const me = new Person("Lee");
```

- 최신 브라우저와 최신 Node.js에서는 클래스 필드를 클래스 몸체에 정의할 수 있음

```jsx
class Person {
  // 클래스 필드 정의
  name = "Lee";
}

const me = new Person();
console.log(me); // Person {name: "Lee"}
```

- 클래스 몸체에서 클래스 필드를 정의하는 경우 this에 클래스 필드를 바인딩해서는 안 됨
- this는 클래스의 constructor와 메서드 내에서만 유효함

```jsx
class Person {
  // this에 클래스 필드를 바인딩해서는 안된다.
  this.name = ''; // SyntaxError: Unexpected token '.'
}
```

- 클래스 필드를 참조하는 경우 자바와 같은 클래스 기반 객체지향 언어에서는 this를 생략할 수 있으나 자바스크립트에서는 this를 반드시 사용해야 함

```jsx
class Person {
  // 클래스 필드
  name = "Lee";

  constructor() {
    console.log(name); // ReferenceError: name is not defined
  }
}

new Person();
```

- 클래스 필드에 초기값을 할당하지 않으면 **undefined**를 가짐

```jsx
class Person {
  // 클래스 필드를 초기화하지 않으면 undefined를 갖는다.
  name;
}

const me = new Person();
console.log(me); // Person {name: undefined}
```

- 인스턴스를 생성할 때 외부의 초기값으로 클래스 필드를 초기화해야 할 필요가 있다면 constructor에서 클래스 필드를 초기화해야 함

```jsx
class Person {
  name;

  constructor(name) {
    // 클래스 필드 초기화.
    this.name = name;
  }
}

const me = new Person("Lee");
console.log(me); // Person {name: "Lee"}
```

- 클래스 필드를 초기화해야 할 필요가 있다면 어차피 constructor 내부에서 클래스 필드를 참조하여 초기값을 할당해야 함
- 이때 this, 즉 클래스가 생성한 인스턴스에 클래스 필드에 해당하는 프로퍼티가 없다면 자동 추가되기 때문임

```jsx
class Person {
  constructor(name) {
    this.name = name;
  }
}

const me = new Person("Lee");
console.log(me); // Person {name: "Lee"}
```

- 함수는 일급 객체이므로 함수를 클래스 필드에 할당할 수 있음
- 따라서 클래스 필드를 통해 메서드를 정의할 수도 있음

```jsx
class Person {
  // 클래스 필드에 문자열을 할당
  name = "Lee";

  // 클래스 필드에 함수를 할당
  getName = function () {
    return this.name;
  };
  // 화살표 함수로 정의할 수도 있다.
  // getName = () => this.name;
}

const me = new Person();
console.log(me); // Person {name: "Lee", getName: ƒ}
console.log(me.getName()); // Lee
```

- 클래스 필드에 함수를 할당하는 경우, 이 함수는 프로토타입 메서드가 아닌 인스턴스 메서드가 됨
- 모든 클래스 필드는 인스턴스 프로퍼티가 되기 때문임
- 따라서 클래스 필드에 함수를 할당하는 것은 권장하지 않음

## 8-4. private 필드 정의 제안

- 자바스크립트는 캡슐화를 완전하게 지원하지 않음
- ES6의 클래스도 생성자 함수와 마찬가지로 다른 클래스 기반 객체지향 언어에서는 지원하는 private, public, protected 키워드와 같은 접근 제한자를 지원하지 않음
- 따라서 인스턴스 프로퍼티는 인스턴스를 통해 클래스 외부에서 언제나 참조할 수 있음 → 즉, 언제나 public임

```jsx
class Person {
  constructor(name) {
    this.name = name; // 인스턴스 프로퍼티는 기본적으로 public하다.
  }
}

// 인스턴스 생성
const me = new Person("Lee");
console.log(me.name); // Lee
```

- 클래스 필드 정의 제안을 사용하더라도 클래스 필드는 기본적으로 public하기 때문에 외부에 그대로 노출됨

```jsx
class Person {
  name = "Lee"; // 클래스 필드도 기본적으로 public하다.
}

// 인스턴스 생성
const me = new Person();
console.log(me.name); // Lee
```

- private 필드의 선두에는 #을 붙여줌
- private 필드를 참조할 때도 #을 붙여주어야 함

```jsx
class Person {
  // private 필드 정의
  #name = "";

  constructor(name) {
    // private 필드 참조
    this.#name = name;
  }
}

const me = new Person("Lee");

// private 필드 #name은 클래스 외부에서 참조할 수 없다.
console.log(me.#name);
// SyntaxError: Private field '#name' must be declared in an enclosing class
```

- public 필드는 어디서든 참조할 수 있지만 private 필드는 클래스 내부에서만 참조할 수 있음
- 이처럼 클래스 외부에서 private 필드에 직접 접근할 수 있는 방법은 없음
- 다만, 접근자 프로퍼티를 통해 간접적으로 접근하는 방법은 유효함

```jsx
class Person {
  // private 필드 정의
  #name = "";

  constructor(name) {
    this.#name = name;
  }

  // name은 접근자 프로퍼티다.
  get name() {
    // private 필드를 참조하여 trim한 다음 반환한다.
    return this.#name.trim();
  }
}

const me = new Person(" Lee ");
console.log(me.name); // Lee
```

- private 필드는 반드시 클래스 몸체에 정의해야 함
- private 필드를 직접 constructor에 정의하면 에러가 발생함

```jsx
class Person {
  constructor(name) {
    // private 필드는 클래스 몸체에서 정의해야 한다.
    this.#name = name;
    // SyntaxError: Private field '#name' must be declared in an enclosing class
  }
}
```

## 8-5. static 필드 정의 제안

- 클래스에는 static 키워드를 사용하여 정적 메서드를 정의할 수 있음
- 하지만 static 키워드를 사용하여 정적 필드를 정의할 수는 없었음
- 하지만 static public 필드, static private 필드, staitc private 메서드를 정의할 수 있는 새로운 표준 사양인 “Static class features”가 TC39 프로세스의 stage 3(candidate)에 제안되어 있음

```jsx
class MyMath {
  // static public 필드 정의
  static PI = 22 / 7;

  // static private 필드 정의
  static #num = 10;

  // static 메서드
  static increment() {
    return ++MyMath.#num;
  }
}

console.log(MyMath.PI); // 3.142857142857143
console.log(MyMath.increment()); // 11
```

# 9. 상속에 의한 클래스 확장

## 9-1. 클래스 상속과 생성자 함수 상속

- 상속에 의한 클래스 확장은 지금까지 살펴본 프로토타입 기반 상속과는 다른 개념임
- 프로토타입 기반 상속은 프로토타입 체인을 통해 다른 객체의 자산을 상속받는 개념이지만 **상속에 의한 클래스 확장은 기존 클래스를 상속받아 새로운 클래스를 확장하여 정의**하는 것임

## 9-2 extends 키워드

- 상속을 통해 클래스를 확장하려면 extends 키워드를 사용하여 상속받을 클래스를 정의함
- 상속을 통해 확장된 클래스를 서브클래스라 부르고, 서브클래스에게 상속된 클래스를 수퍼클래스라 부름
- 서브클래스를 파생클래스 또는 자식클래스, 수퍼클래스를 베이스클래스 또는 부모클래스라고 부르기도 함
- extends 키워드의 역할은 수퍼클래스와 서브클래스 간의 상속 관계를 설정하는 것임
- 클래스도 프로토타입을 통해 상속 관계를 구현함

```jsx
// 수퍼(베이스/부모)클래스
class Base {}

// 서브(파생/자식)클래스
class Derived extends Base {}
```

## 9-3. 동적 상속

- extends 키워드는 클래스 뿐만 아니라 생성자 함수를 상속받아 클래스를 확장할 수도 있음
- 단, extends 키워드 앞에는 반드시 클래스가 와야 함

```jsx
// 생성자 함수
function Base(a) {
  this.a = a;
}

// 생성자 함수를 상속받는 서브클래스
class Derived extends Base {}

const derived = new Derived(1);
console.log(derived); // Derived {a: 1}
```

- extends 키워드 다음에는 클래스 뿐만 아니라 [[Construct]] 내부 메서드를 갖는 함수 객체로 평가될 수 있는 모든 표현식을 사용할 수도 있음
- 이를 통해 동적으로 상속받을 대상을 결정할 수 있음

```jsx
function Base1() {}

class Base2 {}

let condition = true;

// 조건에 따라 동적으로 상속 대상을 결정하는 서브클래스
class Derived extends (condition ? Base1 : Base2) {}

const derived = new Derived();
console.log(derived); // Derived {}

console.log(derived instanceof Base1); // true
console.log(derived instanceof Base2); // false
```

## 9-4. 서브클래스의 constructor

- 클래스에서 constructor를 생략하면 클래스에 다음과 같이 비어있는 constructor가 암묵적으로 정의됨

```jsx
constructor() {}
```

- 서브클래스에서 constructor를 생략하면 클래스에 다음과 같은 constructor가 암묵적으로 정의됨
- args는 new 연산자와 함께 클래스를 호출할 때 전달한 인수의 리스트임

```jsx
constructor(...args) { super(...args); }
```

- 수퍼클래스와 서브클래스 모두 constructor 생략함
- 암묵적으로 constructor가 정의됨

```jsx
// 수퍼클래스
class Base {}

// 서브클래스
class Derived extends Base {}
```

## 9-5. super 키워드

- 함수처럼 호출할 수도 있고 this와 같이 식별자처럼 참조할 수 있는 특수한 키워드
- super를 호출하면 수퍼클래스의 constructor(super-constructor)를 호출함
- super를 참조하면 수퍼클래스의 메서드를 호출할 수 있음

### #super 호출

- super를 호출하면 수퍼클래스의 constructor(super-constructor)를 호출함

```jsx
// 수퍼클래스
class Base {
  constructor(a, b) {
    this.a = a;
    this.b = b;
  }
}

// 서브클래스
class Derived extends Base {
  // 다음과 같이 암묵적으로 constructor가 정의된다.
  // constructor(...args) { super(...args); }
}

const derived = new Derived(1, 2);
console.log(derived); // Derived {a: 1, b: 2}
```

**super를 호출할 때 주의사항**

1. 서브클래스에서 constructor를 생략하지 않는 경우 서브클래스의 constructor에서는 반드시 super를 호출해야 함

```jsx
class Base {}

class Derived extends Base {
  constructor() {
    // ReferenceError: Must call super constructor in derived class before accessing 'this' or returning from derived constructor
    console.log("constructor call");
  }
}

const derived = new Derived();
```

1. 서브클래스의 constructor에서 super를 호출하기 전에는 this를 참조할 수 없음

```jsx
class Base {}

class Derived extends Base {
  constructor() {
    // ReferenceError: Must call super constructor in derived class before accessing 'this' or returning from derived constructor
    this.a = 1;
    super();
  }
}

const derived = new Derived(1);
```

1. super는 반드시 서브클래스의 constructor에서만 호출함, 서브클래스가 아닌 클래스의 constructor이나 함수에서 super를 호출하면 에러 발생

```jsx
class Base {
  constructor() {
    super(); // SyntaxError: 'super' keyword unexpected here
  }
}

function Foo() {
  super(); // SyntaxError: 'super' keyword unexpected here
}
```

### #super 참조

- 메서드 내에서 super를 참조하면 수퍼클래스의 메서드를 호출할 수 있음

1. 서브클래스의 프로토타입 메서드 내에서 super.sayHi는 수퍼클래스의 프로토타입 메서드 sayHi를 가리킴

```jsx
// 수퍼클래스
class Base {
  constructor(name) {
    this.name = name;
  }

  sayHi() {
    return `Hi! ${this.name}`;
  }
}

// 서브클래스
class Derived extends Base {
  sayHi() {
    // super.sayHi는 수퍼클래스의 프로토타입 메서드를 가리킨다.
    return `${super.sayHi()}. how are you doing?`;
  }
}

const derived = new Derived("Lee");
console.log(derived.sayHi()); // Hi! Lee. how are you doing?
```

1. 서브클래스의 정적 메서드 내에서 super.sayHi는 수퍼클래스의 정적 메서드 sayHi를 가리킴

```jsx
// 수퍼클래스
class Base {
  static sayHi() {
    return "Hi!";
  }
}

// 서브클래스
class Derived extends Base {
  static sayHi() {
    // super.sayHi는 수퍼클래스의 정적 메서드를 가리킨다.
    return `${super.sayHi()} how are you doing?`;
  }
}

console.log(Derived.sayHi()); // Hi! how are you doing?
```

## 9-6. 상속 클래스의 인스턴스 생성 과정

1. **서브클래스의 super 호출**
2. **수퍼클래스의 인스턴스 생성과 this 바인딩**

   - 수퍼클래스의 constructor 내부의 코드가 실행되기 이전에 암묵적으로 빈 객체를 생성함
   - 이 빈 객체가 바로 클래스가 생성한 인스턴스임
   - 암묵적으로 생성된 빈 객체, 즉 인스턴스는 this에 바인딩됨
   - 따라서 수퍼클래스의 constructor 내부의 this는 생성된 인스턴스를 가리킴

   ```jsx
   // 수퍼클래스
   class Rectangle {
     constructor(width, height) {
       // 암묵적으로 빈 객체, 즉 인스턴스가 생성되고 this에 바인딩된다.
       console.log(this); // ColorRectangle {}
       // new 연산자와 함께 호출된 함수, 즉 new.target은 ColorRectangle이다.
       console.log(new.target); // ColorRectangle
   ...
   ```

3. **수퍼클래스의 인스턴스 초기화**

   - 수퍼클래스의 constructor가 실행되어 this에 바인딩되어 있는 인스턴스를 초기화함
   - 즉, this에 바인딩되어 있는 인스턴스에 프로퍼티를 추가하고 constructor가 인수로 전달받은 초기값으로 인스턴스의 프로퍼티를 초기화함

   ```jsx
   // 수퍼클래스
   class Rectangle {
     constructor(width, height) {
       // 암묵적으로 빈 객체, 즉 인스턴스가 생성되고 this에 바인딩된다.
       console.log(this); // ColorRectangle {}
       // new 연산자와 함께 호출된 함수, 즉 new.target은 ColorRectangle이다.
       console.log(new.target); // ColorRectangle

       // 생성된 인스턴스의 프로토타입으로 ColorRectangle.prototype이 설정된다.
       console.log(Object.getPrototypeOf(this) === ColorRectangle.prototype); // true
       console.log(this instanceof ColorRectangle); // true
       console.log(this instanceof Rectangle); // true

       // 인스턴스 초기화
       this.width = width;
       this.height = height;

       console.log(this); // ColorRectangle {width: 2, height: 4}
     }
   ...
   ```

4. **서브클래스의 constructor로의 복귀와 this 바인딩**

   - super의 호출이 종료되고 제어 흐름이 서브클래스 constructor로 돌아옴
   - 이때 super가 반환한 인스턴스가 this에 바인딩됨
   - 서브클래스는 별도의 인스턴스를 생성하지 않고 super가 반환한 인스턴스를 this에 바인딩하여 그대로 사용함

   ```jsx
   // 서브클래스
   class ColorRectangle extends Rectangle {
     constructor(width, height, color) {
       super(width, height);

       // super가 반환한 인스턴스가 this에 바인딩된다.
       console.log(this); // ColorRectangle {width: 2, height: 4}
   ...
   ```

   - 이처럼 super가 호출되지 않으면 인스턴스가 생성되지 않으며, this 바인딩도 할 수 없음
   - 서브클래스의 constructor에서 super를 호출하기 전에는 this를 참조할 수 없는 이유가 바로 이 때문임
   - 따라서 서브클래스 constructor 내부의 인스턴스 초기화는 반드시 super 호출 이후에 처리되어야 함

5. **서브클래스의 인스턴스 초기화**
   - super 호출 이후, 서브클래스의 constructor에 기술되어 있는 인스턴스 초기화가 실행됨
   - 즉, this에 바인딩되어 있는 인스턴스에 프로퍼티를 추가하고 constructor가 인수로 전달받은 초기값으로 인스턴스의 프로퍼티를 초기화함
6. **인스턴스 반환**
   - 클래스의 모든 처리가 끝나면 완성된 인스턴스가 바인딩된 tihs가 암묵적으로 반환됨
